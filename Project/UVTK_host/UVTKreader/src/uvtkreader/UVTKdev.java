/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */package uvtkreader;import ch.ntb.usb.Device;import ch.ntb.usb.USB;import ch.ntb.usb.USBException;import ch.ntb.usb.USBTimeoutException;import java.awt.Rectangle;import java.text.*;import java.util.Calendar;import java.util.Date;import java.util.logging.Level;import java.util.logging.Logger;import javax.swing.*;import javax.swing.text.BadLocationException;import javax.swing.text.Document;import javax.swing.text.StyledDocument;public class UVTKdev extends Thread{        private Document bitFlowDoc;    private volatile boolean pauseThread = false;    private DateFormat df;    private static long timeTmp;    Device dev;        private static final int CUSTOM_RQ_SET_INV = 0x00;           private static final int CUSTOM_RQ_SET_DATA = 0x01;    private static final int CUSTOM_RQ_GET = 0x02;        public UVTKdev(){       this.df = new SimpleDateFormat("HH:mm:ss");       timeTmp = System.currentTimeMillis();    }           private  void logData(byte[] data, int sizeOfArr) {                 if (bitFlowDoc == null){            System.out.println("Set Text Area!!!");        }      String binaryStr = "", hexStr = "";      int binaryStrLen = 0;          for (int i = 0; i < sizeOfArr; i++) {        binaryStr = Integer.toString(data[i]& 0xff, 2);        binaryStrLen = binaryStr.length();        if(binaryStrLen < 8){            for(int n = 0; n < (8 - binaryStrLen); n++){                binaryStr =  "0" + binaryStr;            }        }        if((data[i] & 0xff)< 16)           hexStr = "0x0" + Integer.toHexString(data[i] & 0xff).toUpperCase();        else            hexStr = "0x" + Integer.toHexString(data[i] & 0xff).toUpperCase();       // System.out.println("Adding value");        try {                     if(System.currentTimeMillis() - timeTmp > 1000){            timeTmp = System.currentTimeMillis();                    bitFlowDoc.insertString(bitFlowDoc.getLength(), df.format(timeTmp) + " " + hexStr                          + " "+ binaryStr + "\n", null);                   }        else{                      bitFlowDoc.insertString(bitFlowDoc.getLength(), "              " + " " + hexStr                        + " "+ binaryStr + "\n", null);                 }         } catch (BadLocationException ex) {                Logger.getLogger(UVTKdev.class.getName()).log(Level.SEVERE, null, ex);            }                   }    }    public void getTextArea(JTextPane textPane){        this.bitFlowDoc = textPane.getDocument();        }        public void triggerThread (boolean trig){        pauseThread = trig;    }        public void oprosTS(byte KPnum, byte FANG, byte reqType){        try {            byte[] readData = new byte[3];            readData [0] = KPnum;            readData [1] = FANG;            readData [2] = reqType;            dev.controlMsg(USB.REQ_TYPE_TYPE_VENDOR|USB.REQ_TYPE_RECIP_DEVICE|USB.REQ_TYPE_DIR_HOST_TO_DEVICE,                    CUSTOM_RQ_SET_DATA, 1, 0, readData, 3, 5000, true);        } catch (USBException ex) {            Logger.getLogger(UVTKdev.class.getName()).log(Level.SEVERE, null, ex);        }    }        public void setInv(byte invStat){        try {            byte[] readData = new byte[1];            readData [0] = invStat;            dev.controlMsg(USB.REQ_TYPE_TYPE_VENDOR|USB.REQ_TYPE_RECIP_DEVICE|USB.REQ_TYPE_DIR_HOST_TO_DEVICE,                    CUSTOM_RQ_SET_INV, 1, 0, readData, 1, 5000, true);        } catch (USBException ex) {            Logger.getLogger(UVTKdev.class.getName()).log(Level.SEVERE, null, ex);        }     }    @Override  public void run() {    // get a device instance with vendor id and product id    this.dev = USB.getDevice((short) 0x16c0, (short) 0x05dc);    try {      // data to write to the device      byte[] data = new byte[] { 0 , 0, 0, 0, 0, 0, 0, 0};      // data read from the device      byte[] readData = new byte[data.length];            int i = 0;      // open the device with configuration 1, interface 0 and without      // altinterface      // this will initialise Libusb for you      dev.open(1, 0, -1);   //   dev.controlMsg(USB.REQ_TYPE_TYPE_VENDOR|USB.REQ_TYPE_RECIP_DEVICE|USB.REQ_TYPE_DIR_HOST_TO_DEVICE,     //          CUSTOM_RQ_SET, 1, 0, readData, 0, 5000, true);     // dev.controlMsg(USB.REQ_TYPE_TYPE_VENDOR|USB.REQ_TYPE_RECIP_DEVICE|USB.REQ_TYPE_DIR_DEVICE_TO_HOST,     //         CUSTOM_RQ_GET, 0, 0, readData, readData.length, 5000, true);      // write some data to the device      // 0x03 is the endpoint address of the OUT endpoint 3 (from PC to      // device)      //dev.writeInterrupt(0x03, data, data.length, 2000, false);      // read some data from the device      // 0x84 is the endpoint address of the IN endpoint 4 (from PC to      // device)      // bit 7 (0x80) is set in case of an IN endpoint              while(true){          synchronized (this){          if (pauseThread){              try {                  System.out.println("Now dev will sleep");                  this.wait();                  System.out.println("Dev has slept");              } catch (InterruptedException ex) {                  Logger.getLogger(UVTKdev.class.getName()).log(Level.SEVERE, null, ex);              }          }        }          try{                  i = dev.readInterrupt(0x01, readData, readData.length, 1000, false);          }catch (USBTimeoutException e) {             e.printStackTrace();          }        // log the data from the device        logData(readData, i);      }          } catch (USBException e) {      // if an exception occures during connect or read/write an exception      // is throw            e.printStackTrace();    }finally{          try {              dev.close();          } catch (USBException ex) {              Logger.getLogger(UVTKdev.class.getName()).log(Level.SEVERE, null, ex);          }    }  }}